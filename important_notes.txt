//Make sure minilibx-lib is already compiled:
cd minilibx-lib && make && cd .. && cd Libft && make && cd ..

//This is a command of execution:

//When you're at 42 school (At Linux section):
gcc srcs/so_long.c srcs/generate_map.c -o so_long \
-L/home/wwan-ab-/Desktop/so_long/minilibx-lib -lmlx \
-L/home/wwan-ab-/Desktop/so_long/Libft -lft -lXext -lX11

//When you open MacBook:
gcc srcs/so_long.c srcs/generate_map.c -o so_long \
-L/home/idriss/Desktop/so_long/minilibx-lib -lmlx \
-L/home/idriss/Desktop/so_long/Libft -lft -lXext -lX11


//Then run this:
./so_long maps/map1.ber 

//To make erase everything up...
cd minilibx-lib && make clean && cd ../Libft && make fclean && cd .. && rm so_long

If you have any confusion, doubt, or whatever it is that makes you feel bad. Read this documentations:
https://harm-smits.github.io/42docs/libs/minilibx
https://reactive.so/post/42-a-comprehensive-guide-to-so_long/
https://42-cursus.gitbook.io/guide/rank-02/so_long/core-concepts

1) Map 
2) Movements
3) Characters
4) Make a header called 'Macros':

    For example:
        # define TILE 32

5) Put silencing on Makefile
    For example:
        $mkdir -p 

6) Conditional statement in Makefile

7) Don't get confuse with x and y.

8) Focus on filename handling. extension = .ber -> Error handling

9) get_next_line(). -> Make sure fd is valid. - Download file = download_map()

10) Then focus on game

game: This is a pointer to a structure (or union).
map: This is a member (field) of the structure that game points to.
->: This operator dereferences the pointer and accesses the specified member of the structure in one step.


At home:
gcc srcs/so_long.c srcs/generate_map.c srcs/error_checker.c srcs/map_specs.c get_next_line/get_next_line.c get_next_line/get_next_line_utils.c -o so_long -L/home/idriss/Desktop/so_long/minilibx-lib -lmlx -L/home/idriss/Desktop/so_long/Libft -lft -lXext -lX11

At campus:
gcc srcs/so_long.c srcs/generate_map.c srcs/error_checker.c srcs/map_specs.c get_next_line/get_next_line.c get_next_line/get_next_line_utils.c -o so_long -L/home/wwan-ab-/Desktop/so_long/minilibx-lib -lmlx -L/home/wwan-ab-/Desktop/so_long/Libft -lft -lXext -lX11


Yes, it seems like the issues you're encountering are related to the `-fsanitize=address` flag, which is used for memory debugging with AddressSanitizer. Here are a few key points about how it can impact your program:

1. **Segmentation Faults**: When AddressSanitizer detects a memory error, it can terminate the program with a segmentation fault. This is what you're seeing with the "DEADLYSIGNAL" messages.

2. **Interference with Valgrind**: AddressSanitizer and Valgrind can conflict with each other. If you're running Valgrind with a program that was compiled with AddressSanitizer, it can cause unexpected behavior or errors. Valgrind is designed to analyze memory usage, while AddressSanitizer is more focused on detecting specific memory errors.

3. **Debugging**: While AddressSanitizer can provide detailed reports on memory errors, it can also produce a lot of output if there are multiple issues, making it harder to debug if you're not specifically looking for those errors.

### Suggestions

- **Switch Between Sanitizers and Valgrind**: If you want to use Valgrind for memory checking, consider removing the `-fsanitize=address` flag and compile your program without it.

- **Focus on One Tool at a Time**: Use AddressSanitizer to catch memory-related bugs during development, but when you want to perform thorough memory checking, switch to Valgrind.

- **Check Your Code**: Look for common issues that could cause memory errors, such as:
  - Accessing uninitialized memory.
  - Buffer overflows.
  - Double freeing memory.
  - Accessing freed memory.

If you fix the underlying issues in your code, the problems with AddressSanitizer should resolve, and you can benefit from its memory checking capabilities. Let me know if you need help troubleshooting specific parts of your code!